import os
import sys
import argparse
import subprocess
import sqlite3
from datetime import datetime
from dotenv import load_dotenv

# Загружаем переменные окружения из .env файла
load_dotenv()

def run_command(command):
    """Выполняет команду и возвращает код возврата"""
    print(f"Выполняется команда: {command}")
    process = subprocess.Popen(command, shell=True)
    process.communicate()
    return process.returncode

def create_migration(message=None):
    """Создает новую миграцию"""
    if not message:
        message = f"Migration {datetime.now().strftime('%Y%m%d_%H%M%S')}"
    
    cmd = f"alembic revision --autogenerate -m \"{message}\""
    return run_command(cmd)

def upgrade(revision="head"):
    """Обновляет базу данных до указанной ревизии"""
    cmd = f"alembic upgrade {revision}"
    return run_command(cmd)

def downgrade(revision="-1"):
    """Откатывает базу данных на указанную ревизию"""
    cmd = f"alembic downgrade {revision}"
    return run_command(cmd)

def show_current():
    """Показывает текущую версию базы данных"""
    cmd = "alembic current"
    return run_command(cmd)

def show_history():
    """Показывает историю миграций"""
    cmd = "alembic history"
    return run_command(cmd)

def stamp(revision="head"):
    """Устанавливает версию без применения миграций"""
    cmd = f"alembic stamp {revision}"
    return run_command(cmd)

def reset_db():
    """Сбрасывает базу данных и применяет все миграции заново"""
    # Получаем путь к базе данных из переменной окружения
    db_url = os.getenv("DATABASE_URL", "")
    if "sqlite" in db_url:
        # Для SQLite извлекаем путь к файлу
        db_path = db_url.replace("sqlite:///", "")
        if os.path.exists(db_path):
            print(f"Удаление существующей базы данных: {db_path}")
            os.remove(db_path)
            print("База данных удалена.")
    
    print("Применение всех миграций...")
    return upgrade()

def create_manual_migration(name):
    """Создает миграцию с заданным именем и шаблоном"""
    timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
    revision_id = f"{timestamp}_{name.lower().replace(' ', '_')}"
    
    # Создаем папку для миграций, если она не существует
    versions_dir = os.path.join(os.path.dirname(__file__), "migrations", "versions")
    os.makedirs(versions_dir, exist_ok=True)
    
    # Создаем файл миграции
    migration_file = os.path.join(versions_dir, f"{revision_id}.py")
    
    # Получаем последнюю ревизию
    cmd = "alembic current"
    process = subprocess.Popen(cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    stdout, stderr = process.communicate()
    
    # Получаем текущую ревизию из вывода команды
    current_revision = "None"
    if stdout:
        output = stdout.decode('utf-8')
        if "(head)" in output:
            current_revision = output.split("(head)")[0].strip()
    
    # Создаем содержимое миграции
    migration_content = f"""\"""{name}\"\"\"\n\nRevision ID: {revision_id}\nRevises: {current_revision}\nCreate Date: {datetime.now().strftime('%Y-%m-%d %H:%M:%S.%f')}\n\n\"\"\"\nfrom alembic import op\nimport sqlalchemy as sa\n\n\n# revision identifiers, used by Alembic.\nrevision = '{revision_id}'\ndown_revision = '{current_revision}'\nbranch_labels = None\ndepends_on = None\n\n\ndef upgrade() -> None:\n    # ### commands auto generated by Alembic - please adjust! ###\n    # Добавляем недостающие колонки в таблицу users\n    op.add_column('users', sa.Column('reports_count', sa.Integer(), nullable=True, server_default='0'))\n    op.add_column('users', sa.Column('report_category', sa.String(), nullable=True, server_default='normal'))\n    # ### end Alembic commands ###\n\n\ndef downgrade() -> None:\n    # ### commands auto generated by Alembic - please adjust! ###\n    op.drop_column('users', 'report_category')\n    op.drop_column('users', 'reports_count')\n    # ### end Alembic commands ###\n"""
    
    # Записываем содержимое в файл
    with open(migration_file, 'w') as f:
        f.write(migration_content)
    
    print(f"Создана миграция: {migration_file}")
    return 0

def add_missing_columns():
    """Добавляет недостающие колонки в таблицу users напрямую через SQL"""
    # Получаем путь к базе данных из переменной окружения
    db_url = os.getenv("DATABASE_URL", "")
    if not db_url or "sqlite" not in db_url:
        print("Ошибка: Неподдерживаемая база данных или URL не найден")
        return 1
    
    # Для SQLite извлекаем путь к файлу
    db_path = db_url.replace("sqlite:///", "")
    if not os.path.exists(db_path):
        print(f"Ошибка: Файл базы данных не найден: {db_path}")
        return 1
    
    try:
        # Подключаемся к базе данных
        conn = sqlite3.connect(db_path)
        cursor = conn.cursor()
        
        # Проверяем наличие колонки reports_count
        cursor.execute("PRAGMA table_info(users)")
        columns = {column[1]: column for column in cursor.fetchall()}
        
        # Добавляем недостающие колонки
        if 'reports_count' not in columns:
            print("Добавление колонки reports_count...")
            cursor.execute("ALTER TABLE users ADD COLUMN reports_count INTEGER DEFAULT 0")
            print("Колонка reports_count успешно добавлена")
        else:
            print("Колонка reports_count уже существует")
        
        if 'report_category' not in columns:
            print("Добавление колонки report_category...")
            cursor.execute("ALTER TABLE users ADD COLUMN report_category TEXT DEFAULT 'normal'")
            print("Колонка report_category успешно добавлена")
        else:
            print("Колонка report_category уже существует")
        
        # Сохраняем изменения
        conn.commit()
        conn.close()
        
        print("Колонки успешно добавлены в таблицу users")
        return 0
    except sqlite3.Error as e:
        print(f"Ошибка SQLite: {e}")
        return 1
    except Exception as e:
        print(f"Непредвиденная ошибка: {e}")
        return 1



def main():
    # Проверяем наличие переменной окружения DATABASE_URL
    database_url = os.getenv("DATABASE_URL")
    if not database_url:
        print("ОШИБКА: Переменная окружения DATABASE_URL не найдена в файле .env")
        return 1

    parser = argparse.ArgumentParser(description="Управление миграциями базы данных")
    subparsers = parser.add_subparsers(dest="command", help="Команды")
    
    # Команда создания миграции
    create_parser = subparsers.add_parser("create", help="Создать новую миграцию")
    create_parser.add_argument("-m", "--message", help="Сообщение миграции")
    
    # Команда обновления
    upgrade_parser = subparsers.add_parser("upgrade", help="Обновить базу данных")
    upgrade_parser.add_argument("revision", nargs="?", default="head", help="Ревизия для обновления")
    
    # Команда отката
    downgrade_parser = subparsers.add_parser("downgrade", help="Откатить базу данных")
    downgrade_parser.add_argument("revision", nargs="?", default="-1", help="Ревизия для отката")
    
    # Команда показа текущей версии
    subparsers.add_parser("current", help="Показать текущую версию базы данных")
    
    # Команда показа истории миграций
    subparsers.add_parser("history", help="Показать историю миграций")
    
    # Команда установки версии без применения миграций
    stamp_parser = subparsers.add_parser("stamp", help="Установить версию без применения миграций")
    stamp_parser.add_argument("revision", nargs="?", default="head", help="Ревизия для установки")
    
    # Команда сброса базы данных
    subparsers.add_parser("reset", help="Сбросить базу данных и применить все миграции заново")
    
    
    # Команда автоматического исправления схемы
    subparsers.add_parser("fix", help="Автоматически создать и применить миграцию для исправления схемы")
    
    # Команда добавления недостающих колонок
    subparsers.add_parser("add-columns", help="Добавить недостающие колонки в таблицу users")
    
    args = parser.parse_args()
    
    if args.command == "create":
        return create_migration(args.message)
    elif args.command == "upgrade":
        return upgrade(args.revision)
    elif args.command == "downgrade":
        return downgrade(args.revision)
    elif args.command == "current":
        return show_current()
    elif args.command == "history":
        return show_history()
    elif args.command == "stamp":
        return stamp(args.revision)
    elif args.command == "reset":
        return reset_db()

    elif args.command == "fix":
        # Автоматически создаем и применяем миграцию для исправления схемы
        message = f"Auto-fix schema inconsistencies {datetime.now().strftime('%Y%m%d_%H%M%S')}"
        create_result = create_migration(message)
        if create_result == 0:
            print("\nМиграция успешно создана. Применяем миграцию...")
            return upgrade()
        else:
            print("\nОшибка при создании миграции.")
            return create_result
    elif args.command == "add-columns":
        return add_missing_columns()
    else:
        parser.print_help()
        return 1

if __name__ == "__main__":
    sys.exit(main())